package mr

import (
	"fmt"
	"sort"
	"strings"
	"testing"
	"unicode"
)

func Test_process_1(t *testing.T) {
	registerReply := &RegisterReply{
		Finish:     false,
		WorkerID:   1,
		TaskType:   TaskTypeMap,
		MapNums:    2,
		ReduceNums: 1,
		FileNames:  []string{"pg-tom_sawyer.txt"},
	}
	process(registerReply, Map, Reduce)
}

func Test_process_2(t *testing.T) {
	registerReply := &RegisterReply{
		Finish:     false,
		WorkerID:   0,
		TaskType:   TaskTypeReduce,
		MapNums:    2,
		ReduceNums: 1,
		FileNames:  []string{"mr-1-0", "mr-0-0"},
	}
	process(registerReply, Map, Reduce)
}

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a mr.KeyValue.
func Map(document string, value string) (res []KeyValue) {
	m := make(map[string]bool)
	words := strings.FieldsFunc(value, func(x rune) bool { return !unicode.IsLetter(x) })
	for _, w := range words {
		m[w] = true
	}
	for w := range m {
		kv := KeyValue{w, document}
		res = append(res, kv)
	}
	return
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func Reduce(key string, values []string) string {
	sort.Strings(values)
	return fmt.Sprintf("%d %s", len(values), strings.Join(values, ","))
}

func TestCallExample(t *testing.T) {
	CallExample()
}

func Test_register(t *testing.T) {
	for i := 0; i < 9; i++ {
		res, err := register()
		fmt.Println(res, err)
	}

}
